// popmotion@11.0.5 downloaded from https://ga.jspm.io/npm:popmotion@11.0.5/dist/es/index.mjs

import{__rest as t}from"tslib";import{warning as e,invariant as n}from"hey-listen";import{hex as o,rgba as s,hsla as r,color as i,complex as u}from"style-value-types";import l,{cancelSync as p,getFrameData as f}from"framesync";const clamp=(t,e,n)=>Math.min(Math.max(n,t),e);const d=.001;const h=.01;const m=10;const y=.05;const g=1;function findSpring({duration:t=800,bounce:n=.25,velocity:o=0,mass:s=1}){let r;let i;e(t<=1e3*m,"Spring duration must be 10 seconds or less");let u=1-n;u=clamp(y,g,u);t=clamp(h,m,t/1e3);if(u<1){r=e=>{const n=e*u;const s=n*t;const r=n-o;const i=calcAngularFreq(e,u);const l=Math.exp(-s);return d-r/i*l};i=e=>{const n=e*u;const s=n*t;const i=s*o+o;const l=Math.pow(u,2)*Math.pow(e,2)*t;const p=Math.exp(-s);const f=calcAngularFreq(Math.pow(e,2),u);const h=-r(e)+d>0?-1:1;return h*((i-l)*p)/f}}else{r=e=>{const n=Math.exp(-e*t);const s=(e-o)*t+1;return n*s-d};i=e=>{const n=Math.exp(-e*t);const s=t*t*(o-e);return n*s}}const l=5/t;const p=approximateRoot(r,i,l);t*=1e3;if(isNaN(p))return{stiffness:100,damping:10,duration:t};{const e=Math.pow(p,2)*s;return{stiffness:e,damping:2*u*Math.sqrt(s*e),duration:t}}}const v=12;function approximateRoot(t,e,n){let o=n;for(let n=1;n<v;n++)o-=t(o)/e(o);return o}function calcAngularFreq(t,e){return t*Math.sqrt(1-e*e)}const M=["duration","bounce"];const x=["stiffness","damping","mass"];function isSpringType(t,e){return e.some((e=>void 0!==t[e]))}function getSpringOptions(t){let e=Object.assign({velocity:0,stiffness:100,damping:10,mass:1,isResolvedFromDuration:false},t);if(!isSpringType(t,x)&&isSpringType(t,M)){const n=findSpring(t);e=Object.assign(Object.assign(Object.assign({},e),n),{velocity:0,mass:1});e.isResolvedFromDuration=true}return e}function spring(e){var{from:n=0,to:o=1,restSpeed:s=2,restDelta:r}=e,i=t(e,["from","to","restSpeed","restDelta"]);const u={done:false,value:n};let{stiffness:l,damping:p,mass:f,velocity:d,duration:h,isResolvedFromDuration:m}=getSpringOptions(i);let y=zero;let g=zero;function createSpring(){const t=d?-d/1e3:0;const e=o-n;const s=p/(2*Math.sqrt(l*f));const i=Math.sqrt(l/f)/1e3;void 0===r&&(r=Math.min(Math.abs(o-n)/100,.4));if(s<1){const n=calcAngularFreq(i,s);y=r=>{const u=Math.exp(-s*i*r);return o-u*((t+s*i*e)/n*Math.sin(n*r)+e*Math.cos(n*r))};g=o=>{const r=Math.exp(-s*i*o);return s*i*r*(Math.sin(n*o)*(t+s*i*e)/n+e*Math.cos(n*o))-r*(Math.cos(n*o)*(t+s*i*e)-n*e*Math.sin(n*o))}}else if(1===s)y=n=>o-Math.exp(-i*n)*(e+(t+i*e)*n);else{const n=i*Math.sqrt(s*s-1);y=r=>{const u=Math.exp(-s*i*r);const l=Math.min(n*r,300);return o-u*((t+s*i*e)*Math.sinh(l)+n*e*Math.cosh(l))/n}}}createSpring();return{next:t=>{const e=y(t);if(m)u.done=t>=h;else{const n=1e3*g(t);const i=Math.abs(n)<=s;const l=Math.abs(o-e)<=r;u.done=i&&l}u.value=u.done?o:e;return u},flipTarget:()=>{d=-d;[n,o]=[o,n];createSpring()}}}spring.needsInterpolation=(t,e)=>"string"===typeof t||"string"===typeof e;const zero=t=>0;const progress=(t,e,n)=>{const o=e-t;return 0===o?1:(n-t)/o};const mix=(t,e,n)=>-n*t+n*e+t;function hueToRgb(t,e,n){n<0&&(n+=1);n>1&&(n-=1);return n<1/6?t+6*(e-t)*n:n<.5?e:n<2/3?t+(e-t)*(2/3-n)*6:t}function hslaToRgba({hue:t,saturation:e,lightness:n,alpha:o}){t/=360;e/=100;n/=100;let s=0;let r=0;let i=0;if(e){const o=n<.5?n*(1+e):n+e-n*e;const u=2*n-o;s=hueToRgb(u,o,t+1/3);r=hueToRgb(u,o,t);i=hueToRgb(u,o,t-1/3)}else s=r=i=n;return{red:Math.round(255*s),green:Math.round(255*r),blue:Math.round(255*i),alpha:o}}const mixLinearColor=(t,e,n)=>{const o=t*t;const s=e*e;return Math.sqrt(Math.max(0,n*(s-o)+o))};const S=[o,s,r];const getColorType=t=>S.find((e=>e.test(t)));const notAnimatable=t=>`'${t}' is not an animatable color. Use the equivalent color code instead.`;const mixColor=(t,e)=>{let o=getColorType(t);let i=getColorType(e);n(!!o,notAnimatable(t));n(!!i,notAnimatable(e));let u=o.parse(t);let l=i.parse(e);if(o===r){u=hslaToRgba(u);o=s}if(i===r){l=hslaToRgba(l);i=s}const p=Object.assign({},u);return t=>{for(const e in p)"alpha"!==e&&(p[e]=mixLinearColor(u[e],l[e],t));p.alpha=mix(u.alpha,l.alpha,t);return o.transform(p)}};const O={x:0,y:0,z:0};const isNum=t=>"number"===typeof t;const combineFunctions=(t,e)=>n=>e(t(n));const pipe=(...t)=>t.reduce(combineFunctions);function getMixer(t,e){return isNum(t)?n=>mix(t,e,n):i.test(t)?mixColor(t,e):mixComplex(t,e)}const mixArray=(t,e)=>{const n=[...t];const o=n.length;const s=t.map(((t,n)=>getMixer(t,e[n])));return t=>{for(let e=0;e<o;e++)n[e]=s[e](t);return n}};const mixObject=(t,e)=>{const n=Object.assign(Object.assign({},t),e);const o={};for(const s in n)void 0!==t[s]&&void 0!==e[s]&&(o[s]=getMixer(t[s],e[s]));return t=>{for(const e in o)n[e]=o[e](t);return n}};function analyse(t){const e=u.parse(t);const n=e.length;let o=0;let s=0;let r=0;for(let t=0;t<n;t++)o||"number"===typeof e[t]?o++:void 0!==e[t].hue?r++:s++;return{parsed:e,numNumbers:o,numRGB:s,numHSL:r}}const mixComplex=(t,n)=>{const o=u.createTransformer(n);const s=analyse(t);const r=analyse(n);const i=s.numHSL===r.numHSL&&s.numRGB===r.numRGB&&s.numNumbers>=r.numNumbers;if(i)return pipe(mixArray(s.parsed,r.parsed),o);e(true,`Complex values '${t}' and '${n}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);return e=>`${e>0?n:t}`};const mixNumber=(t,e)=>n=>mix(t,e,n);function detectMixerFactory(t){return"number"===typeof t?mixNumber:"string"===typeof t?i.test(t)?mixColor:mixComplex:Array.isArray(t)?mixArray:"object"===typeof t?mixObject:void 0}function createMixers(t,e,n){const o=[];const s=n||detectMixerFactory(t[0]);const r=t.length-1;for(let n=0;n<r;n++){let r=s(t[n],t[n+1]);if(e){const t=Array.isArray(e)?e[n]:e;r=pipe(t,r)}o.push(r)}return o}function fastInterpolate([t,e],[n]){return o=>n(progress(t,e,o))}function slowInterpolate(t,e){const n=t.length;const o=n-1;return s=>{let r=0;let i=false;if(s<=t[0])i=true;else if(s>=t[o]){r=o-1;i=true}if(!i){let e=1;for(;e<n;e++)if(t[e]>s||e===o)break;r=e-1}const u=progress(t[r],t[r+1],s);return e[r](u)}}function interpolate(t,e,{clamp:o=true,ease:s,mixer:r}={}){const i=t.length;n(i===e.length,"Both input and output ranges must be the same length");n(!s||!Array.isArray(s)||s.length===i-1,"Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values.");if(t[0]>t[i-1]){t=[].concat(t);e=[].concat(e);t.reverse();e.reverse()}const u=createMixers(e,s,r);const l=2===i?fastInterpolate(t,u):slowInterpolate(t,u);return o?e=>l(clamp(t[0],t[i-1],e)):l}const reverseEasing=t=>e=>1-t(1-e);const mirrorEasing=t=>e=>e<=.5?t(2*e)/2:(2-t(2*(1-e)))/2;const createExpoIn=t=>e=>Math.pow(e,t);const createBackIn=t=>e=>e*e*((t+1)*e-t);const createAnticipate=t=>{const e=createBackIn(t);return t=>(t*=2)<1?.5*e(t):.5*(2-Math.pow(2,-10*(t-1)))};const T=1.525;const w=4/11;const A=8/11;const R=.9;const linear=t=>t;const F=createExpoIn(2);const D=reverseEasing(F);const j=mirrorEasing(F);const circIn=t=>1-Math.sin(Math.acos(t));const q=reverseEasing(circIn);const I=mirrorEasing(q);const P=createBackIn(T);const k=reverseEasing(P);const E=mirrorEasing(P);const B=createAnticipate(T);const C=4356/361;const N=35442/1805;const U=16061/1805;const bounceOut=t=>{if(1===t||0===t)return t;const e=t*t;return t<w?7.5625*e:t<A?9.075*e-9.9*t+3.4:t<R?C*e-N*t+U:10.8*t*t-20.52*t+10.72};const z=reverseEasing(bounceOut);const bounceInOut=t=>t<.5?.5*(1-bounceOut(1-2*t)):.5*bounceOut(2*t-1)+.5;function defaultEasing(t,e){return t.map((()=>e||j)).splice(0,t.length-1)}function defaultOffset(t){const e=t.length;return t.map(((t,n)=>0!==n?n/(e-1):0))}function convertOffsetToTimes(t,e){return t.map((t=>t*e))}function keyframes({from:t=0,to:e=1,ease:n,offset:o,duration:s=300}){const r={done:false,value:t};const i=Array.isArray(e)?e:[t,e];const u=convertOffsetToTimes(o&&o.length===i.length?o:defaultOffset(i),s);function createInterpolator(){return interpolate(u,i,{ease:Array.isArray(n)?n:defaultEasing(i,n)})}let l=createInterpolator();return{next:t=>{r.value=l(t);r.done=t>=s;return r},flipTarget:()=>{i.reverse();l=createInterpolator()}}}function decay({velocity:t=0,from:e=0,power:n=.8,timeConstant:o=350,restDelta:s=.5,modifyTarget:r}){const i={done:false,value:e};let u=n*t;const l=e+u;const p=void 0===r?l:r(l);p!==l&&(u=p-e);return{next:t=>{const e=-u*Math.exp(-t/o);i.done=!(e>s||e<-s);i.value=i.done?p:p+e;return i},flipTarget:()=>{}}}const $={keyframes:keyframes,spring:spring,decay:decay};function detectAnimationFromOptions(t){if(Array.isArray(t.to))return keyframes;if($[t.type])return $[t.type];const e=new Set(Object.keys(t));return e.has("ease")||e.has("duration")&&!e.has("dampingRatio")?keyframes:e.has("dampingRatio")||e.has("stiffness")||e.has("mass")||e.has("damping")||e.has("restSpeed")||e.has("restDelta")?spring:keyframes}function loopElapsed(t,e,n=0){return t-e-n}function reverseElapsed(t,e,n=0,o=true){return o?loopElapsed(e+-t,e,n):e-(t-e)+n}function hasRepeatDelayElapsed(t,e,n,o){return o?t>=e+n:t<=-n}const framesync=t=>{const passTimestamp=({delta:e})=>t(e);return{start:()=>l.update(passTimestamp,true),stop:()=>p.update(passTimestamp)}};function animate(e){var n,o;var{from:s,autoplay:r=true,driver:i=framesync,elapsed:u=0,repeat:l=0,repeatType:p="loop",repeatDelay:f=0,onPlay:d,onStop:h,onComplete:m,onRepeat:y,onUpdate:g}=e,v=t(e,["from","autoplay","driver","elapsed","repeat","repeatType","repeatDelay","onPlay","onStop","onComplete","onRepeat","onUpdate"]);let{to:M}=v;let x;let S=0;let O=v.duration;let T;let w=false;let A=true;let R;const F=detectAnimationFromOptions(v);if(null===(o=(n=F).needsInterpolation)||void 0===o?void 0:o.call(n,s,M)){R=interpolate([0,100],[s,M],{clamp:false});s=0;M=100}const D=F(Object.assign(Object.assign({},v),{from:s,to:M}));function repeat(){S++;if("reverse"===p){A=S%2===0;u=reverseElapsed(u,O,f,A)}else{u=loopElapsed(u,O,f);"mirror"===p&&D.flipTarget()}w=false;y&&y()}function complete(){x.stop();m&&m()}function update(t){A||(t=-t);u+=t;if(!w){const t=D.next(Math.max(0,u));T=t.value;R&&(T=R(T));w=A?t.done:u<=0}null===g||void 0===g?void 0:g(T);if(w){0===S&&(null!==O&&void 0!==O?O:O=u);S<l?hasRepeatDelayElapsed(u,O,f,A)&&repeat():complete()}}function play(){null===d||void 0===d?void 0:d();x=i(update);x.start()}r&&play();return{stop:()=>{null===h||void 0===h?void 0:h();x.stop()}}}function velocityPerSecond(t,e){return e?t*(1e3/e):0}function inertia({from:t=0,velocity:e=0,min:n,max:o,power:s=.8,timeConstant:r=750,bounceStiffness:i=500,bounceDamping:u=10,restDelta:l=1,modifyTarget:p,driver:d,onUpdate:h,onComplete:m,onStop:y}){let g;function isOutOfBounds(t){return void 0!==n&&t<n||void 0!==o&&t>o}function boundaryNearest(t){return void 0===n?o:void 0===o||Math.abs(n-t)<Math.abs(o-t)?n:o}function startAnimation(t){null===g||void 0===g?void 0:g.stop();g=animate(Object.assign(Object.assign({},t),{driver:d,onUpdate:e=>{var n;null===h||void 0===h?void 0:h(e);null===(n=t.onUpdate)||void 0===n?void 0:n.call(t,e)},onComplete:m,onStop:y}))}function startSpring(t){startAnimation(Object.assign({type:"spring",stiffness:i,damping:u,restDelta:l},t))}if(isOutOfBounds(t))startSpring({from:t,velocity:e,to:boundaryNearest(t)});else{let o=s*e+t;"undefined"!==typeof p&&(o=p(o));const i=boundaryNearest(o);const u=i===n?-1:1;let d;let h;const checkBoundary=t=>{d=h;h=t;e=velocityPerSecond(t-d,f().delta);(1===u&&t>i||-1===u&&t<i)&&startSpring({from:t,to:i,velocity:e})};startAnimation({type:"decay",from:t,velocity:e,timeConstant:r,power:s,restDelta:l,modifyTarget:p,onUpdate:isOutOfBounds(o)?checkBoundary:void 0})}return{stop:()=>null===g||void 0===g?void 0:g.stop()}}const radiansToDegrees=t=>180*t/Math.PI;const angle=(t,e=O)=>radiansToDegrees(Math.atan2(e.y-t.y,e.x-t.x));const applyOffset=(t,e)=>{let n=true;if(void 0===e){e=t;n=false}return o=>{if(n)return o-t+e;t=o;n=true;return e}};const identity=t=>t;const createAttractor=(t=identity)=>(e,n,o)=>{const s=n-o;const r=-(0-e+1)*(0-t(Math.abs(s)));return s<=0?n+r:n-r};const G=createAttractor();const H=createAttractor(Math.sqrt);const degreesToRadians=t=>t*Math.PI/180;const isPoint=t=>t.hasOwnProperty("x")&&t.hasOwnProperty("y");const isPoint3D=t=>isPoint(t)&&t.hasOwnProperty("z");const distance1D=(t,e)=>Math.abs(t-e);function distance(t,e){if(isNum(t)&&isNum(e))return distance1D(t,e);if(isPoint(t)&&isPoint(e)){const n=distance1D(t.x,e.x);const o=distance1D(t.y,e.y);const s=isPoint3D(t)&&isPoint3D(e)?distance1D(t.z,e.z):0;return Math.sqrt(Math.pow(n,2)+Math.pow(o,2)+Math.pow(s,2))}}const pointFromVector=(t,e,n)=>{e=degreesToRadians(e);return{x:n*Math.cos(e)+t.x,y:n*Math.sin(e)+t.y}};const toDecimal=(t,e=2)=>{e=Math.pow(10,e);return Math.round(t*e)/e};const smoothFrame=(t,e,n,o=0)=>toDecimal(t+n*(e-t)/Math.max(o,n));const smooth=(t=50)=>{let e=0;let n=0;return o=>{const s=f().timestamp;const r=s!==n?s-n:0;const i=r?smoothFrame(e,o,r,t):e;n=s;e=i;return i}};const snap=t=>{if("number"===typeof t)return e=>Math.round(e/t)*t;{let e=0;const n=t.length;return o=>{let s=Math.abs(t[0]-o);for(e=1;e<n;e++){const r=t[e];const i=Math.abs(r-o);if(0===i)return r;if(i>s)return t[e-1];if(e===n-1)return r;s=i}}}};function velocityPerFrame(t,e){return t/(1e3/e)}const wrap=(t,e,n)=>{const o=e-t;return((n-t)%o+o)%o+t};const a=(t,e)=>1-3*e+3*t;const b=(t,e)=>3*e-6*t;const c=t=>3*t;const calcBezier=(t,e,n)=>((a(e,n)*t+b(e,n))*t+c(e))*t;const getSlope=(t,e,n)=>3*a(e,n)*t*t+2*b(e,n)*t+c(e);const L=1e-7;const X=10;function binarySubdivide(t,e,n,o,s){let r;let i;let u=0;do{i=e+(n-e)/2;r=calcBezier(i,o,s)-t;r>0?n=i:e=i}while(Math.abs(r)>L&&++u<X);return i}const J=8;const K=.001;function newtonRaphsonIterate(t,e,n,o){for(let s=0;s<J;++s){const s=getSlope(e,n,o);if(0===s)return e;const r=calcBezier(e,n,o)-t;e-=r/s}return e}const Q=11;const V=1/(Q-1);function cubicBezier(t,e,n,o){if(t===e&&n===o)return linear;const s=new Float32Array(Q);for(let e=0;e<Q;++e)s[e]=calcBezier(e*V,t,n);function getTForX(e){let o=0;let r=1;const i=Q-1;for(;r!==i&&s[r]<=e;++r)o+=V;--r;const u=(e-s[r])/(s[r+1]-s[r]);const l=o+u*V;const p=getSlope(l,t,n);return p>=K?newtonRaphsonIterate(e,l,t,n):0===p?l:binarySubdivide(e,o,o+V,t,n)}return t=>0===t||1===t?t:calcBezier(getTForX(t),e,o)}const steps=(t,e="end")=>n=>{n="end"===e?Math.min(n,.999):Math.max(n,.001);const o=n*t;const s="end"===e?Math.floor(o):Math.ceil(o);return clamp(0,1,s/t)};export{angle,animate,B as anticipate,applyOffset,G as attract,H as attractExpo,P as backIn,E as backInOut,k as backOut,z as bounceIn,bounceInOut,bounceOut,circIn,I as circInOut,q as circOut,clamp,createAnticipate,createAttractor,createBackIn,createExpoIn,cubicBezier,decay,degreesToRadians,distance,F as easeIn,j as easeInOut,D as easeOut,inertia,interpolate,isPoint,isPoint3D,keyframes,linear,mirrorEasing,mix,mixColor,mixComplex,pipe,pointFromVector,progress,radiansToDegrees,reverseEasing,smooth,smoothFrame,snap,spring,steps,toDecimal,velocityPerFrame,velocityPerSecond,wrap};

